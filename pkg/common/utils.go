package common

import (
	"reflect"
	"github.com/google/logger"
	"myproj.com/clmgr-lrm/config"
	"net/http"
	"strings"
	"encoding/json"
)

/*
	GetFromSlice() takes slice and searches an item in it
	returns number in slice and item in slice;
			-1 and nil if found nothing
*/
func GetFromSlice(items []interface{}, item interface{}) (int, interface{}) {
	for i := range items {
		if reflect.DeepEqual(items[i], item) {
			return i, items[i]
		}
	}
	return -1, nil
}

func GetFromSliceF(items []interface{}, item interface{}, fn func(interface{}) interface{}) (int, interface{}) {
	for i := range items {
		if reflect.DeepEqual(fn(items[i]), item) {
			return i, items[i]
		}
	}
	return -1, nil
}

/*
	ToInterface() turns slice []T into []interface{}
 */
func ToInterface(slice interface{}) []interface{} {
	s := reflect.ValueOf(slice)
	if s.Kind() != reflect.Slice {
		logger.Error("There wasn't a slice sent as an argument to InterfaceSlice")
		return nil
	}

	ret := make([]interface{}, s.Len())

	for i := 0; i < s.Len(); i++ {
		ret[i] = s.Index(i).Interface()
	}

	return ret
}

/*
	IsError() tells if the interface{} value contains error
*/
func IsError(item interface{}) bool {
	if _, ok := item.(error); !ok {
		if _, ok := item.(*error); !ok {
			return false
		}
	}
	return true
}

const hostnameReq = "hostname"

/*
	GetHostname() gets uuid of cur node, generated by coordinator
 */
func GetHostname() string {
	url := strings.Join([]string{"http://"+config.Config.CoordinatorAddress, hostnameReq}, "/")
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		logger.Errorf("GetHostname request error: %s", err)
		return ""
	}
	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		logger.Errorf("Cant perform request, err: %s", err)
		return ""
	}
	defer resp.Body.Close()

	var s struct {
		Hostname string `json:"hostname"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&s); err != nil {
		logger.Errorf("Can't unmarshal json, err %s", err.Error())
		return ""
	}
	return s.Hostname
}
